# Условие
Берляндия состоит из n городов. Изначально все города изолированы, то есть между городами нету дорог.

По очереди будут добавляться дороги между парами городов. Необходимо после каждой добавленной дороги узнать, какое количество компонент связности из городов получилось.

## Input

Первая строка входного файла содержит два целых числа n и q ($1 \le n, q \le 5*10^5$) — количество городов и запросов соответственно.

Каждая из следующих q строк содержит два целых числа u, v — между какой парой городов будет построена дорога. В данной задаче между любой парой городов строится не более одной дороги, а для любого запроса справедливо $u \ne v$
## Output

На каждый запрос второго типа необходимо вывести одно число — количество компонент связности в графе из городов.

## Example
input:
5 5
1 2
3 4
1 3
3 5
1 5
output:
4
3
2
1
1

---

# Алгоритм решения 
## Пердположение
Перед первым запросом число компонент связности равно числу вершин и с каждым последующим запросом оно либо уменьшиться на единицу, либо не измениться, в случае, если ребро проложат внутри одной компоненты. 

То есть нам нужно знать на каждом запросе в одной ли компоненте лежать вершины или нет, если в разных, то уменьшить счётчик на единицу и сохранить информацию о принадлежности вершины какой-то из компонент, иначе ничего не делать.
## Реализация
Мы просто сохраняем для каждого элемента главного (лидера) в его компоненте связности.

Можно воспользоваться обычным массивом, где индекс - номер вершины, а значение - лидер у данной вершины. 

при каждом новом запросе вида $(u, v)$ объединяем множество, в котором находится $u$ со множеством, где находится $v$

Ограничение на $10^9$ операций, а у нас $5*10^5$ элементов, значит необходимо найти алгоритм, работающий максимум за $O(Nlog(N))$, точнее, объединение множеств должно происходить за логарифм.

Для этого будем хранить ещё и размер множества для каждого лидера. Для экономии памяти можно просто сохранять его отрицательным числом, а не заводить отдельный массив.

Лидера множества будем находить рекурсивно, присваивая его по пути всем затронутым вершинам. Индикатором того, что мы нашли лидера будет то, что в массиве его значение отрицательное.

$$
Leader(x) = 
\begin{cases} 
 x & \text{if } a[x] < 0 \\
Leader(a[x])
\end{cases} 
$$

Для объединения множеств найдём лидеров двух вершин по формуле вверху.
Если лидеры одинаковые, то уменьшим счётчик компонент связности в ответе на запрос
Если лидеры разные, то присоединим меньшее множество к большему, не забыв обновить размер большего множества. Для этого присвоим в массиве элементу по индексу лидера меньшего множества значение лидера большего множества.
$$a[u] += a[v]$$
$$a[v] = u$$


