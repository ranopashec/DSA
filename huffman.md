# Условие
Кодирование Хаффмана (D. A. Huffman) относится к префиксному кодированию, позволяющему минимизировать длину текста за счёт того, что различные символы кодируются различным числом битов.

Напомним процесс построения кода. Вначале строится дерево кода Хаффмана. Пусть исходный алфавит состоит из nn символов, ii-й из которых встречается pipi​ раз во входном тексте. Изначально все символы считаются активными вершинами будущего дерева, ii-я вершина помечена значением pipi​. На каждом шаге мы берём две активных вершины с наименьшими метками, создаём новую вершину, помечая её суммой меток этих вершин, и делаем её их родителем. Новая вершина становится активной, а двое её сыновей из списка активных вершин удаляются. Процесс многократно повторяется, пока не останется только одна активная вершина, которая полагается корнем дерева.

Заметим, что символы алфавита представлены листьями этого дерева. Для каждого листа (символа) длина его кода Хаффмана равна длине пути от корня дерева до него. Сам код строится следующим образом: для каждой внутренней вершины дерева рассмотрим две дуги, идущие от неё к сыновьям. Одной из дуг присвоим метку 00, другой — 11. Код каждого символа — последовательность из нулей и единиц на пути от корня к листу.

Задача состоит в том, чтобы вычислить длину текста после его кодирования методом Хаффмана. Сам текст не дан, известно лишь, сколько раз каждый символ встречается в тексте. Этого достаточно для решения задачи, поскольку длина кода зависит только от частоты появления символов. 

Разработайте алгоритм, работающий за n, где n - количество частот появления символов. 

## Input

Первая строка содержит целое число nn (2≤n≤25000002≤n≤2500000).

Вторая строка содержит nn чисел pipi​ — частоты появления символов в тексте (1≤pi≤1091≤pi​≤109, pi≤pi+1pi​≤pi+1​ для каждого ii от 11 до n−1n−1).

## Output

Выведите единственное число — длину (в битах) закодированного текста.

## Example
input: 
6 
1 1 2 2 5 8
output: 
42

# Алгоритм решения
Достаточно очевидно, что ответом на задачу является сумма значений внутренних вершин дерева, можете попробовать доказать это сами. 

Для нахождения этой суммы заведём:
- массив a - листья в порядке возрастания,
- n - длина массива a
- массив b длины n - 1 - внутренние вершины дерева Хаффмана
- индексы $i_a, j_a$ для первого массива и  $i_b, j_b$ для второго
- sum - сумма внутренних вершин (ответ на задачу)

Установим индексы в начальное положение:

$$a = (1, 1, 2, 2, 5, 6)$$
$$b = ( )$$
$$i_a = 0, j_a = 1, i_b = 0, j_b = 1$$
$$sum = 0$$

Затем просто будем идти по двум массивам, , находя два
минимальных элемента из  $a[i_a], a[j_a], b[i_b], b[j_b]$, добавляя их сумму в конец массива b. 

Нужно учесть, что если индекс вышел за пределы массива, то вместо числа для сравнения берётся бесконечность.

Можно учесть, что $a[i_a] \le a[j_a]$ и $b[i_b] \le b[j_b]$, чтобы составить простое условие инкремента (сдвига индекса)

Пока меньше трёх индексов вышли за предел массива делаем:
Если $b[j_b] < a[i_a]$ то:
$$i_b = i_b + 2$$
$$j_b = j_b + 2$$
$$sum = sum + b[i_b] + b[j_b]$$
Иначе если $b[i_b] < a[j_a]$ то:
$$i_b = i_b + 1$$
$$j_b = j_b + 1$$
$$i_a = i_a + 1$$
$$j_a = j_a + 1$$
$$sum = sum + a[i_a] + b[i_b]$$
Иначе:
$$i_a = i_a + 2$$
$$j_a = j_a + 2$$
$$sum = sum + a[i_a] + a[j_a]$$
